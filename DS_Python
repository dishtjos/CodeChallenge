from ast import Break
import pdb
class TreeNode():
    def __init__(self, val=0, right=None, left=None):
        self.right = right
        self.left = left
        self.val = val

def create_binary_tree(input_array):
    if not input_array:
        return None
    tree_root = TreeNode(input_array[0])
    dummy = TreeNode()
    queue = [dummy]
    queue.append(tree_root)
    index = 1
    while(len(queue) != 1):
        node = queue[1]
        del queue[1]
        if index < len(input_array):
            left_node = TreeNode(input_array[index])
            queue.append(left_node)
            index += 1
            node.left = left_node
        if index < len(input_array):
            right_node = TreeNode(input_array[index])
            queue.append(right_node)
            index += 1
            node.right = right_node
    return tree_root

def breadth_first_search(tree_root):
    queue = []
    queue.append(tree_root)
    while(len(queue)!=0):
        node = queue[0]
        queue.remove(queue[0])
        if node:
            print(node.val)
            queue.append(node.left)
            queue.append(node.right)
    return

def delete_node(tree_root, del_val):
    curr_node = tree_root
    prev_node = None
    is_direction_left = None
    while(curr_node):
        if curr_node.val != del_val:
            prev_node = curr_node
            if curr_node.val > del_val:
                curr_node = curr_node.left
                is_direction_left = True
            else:
                curr_node = curr_node.right
                is_direction_left = False
        else:
            if any([curr_node.left, curr_node.right]):
                next_node = curr_node.right
                if next_node.left is None:
                    if is_direction_left:
                        prev_node.left = next_node
                    else:
                        prev_node.right = next_node
                    del curr_node
                    break
                temp_curr_node = temp_prev_node = next_node
                while(temp_curr_node.left != None):
                    temp_prev_node = temp_curr_node
                    temp_curr_node = temp_curr_node.left
                curr_node.val, temp_curr_node.val = temp_curr_node.val, curr_node.val
                if temp_curr_node.right is None:
                    temp_prev_node.left = None 
                else:
                    temp_prev_node.left = temp_curr_node.right
                del temp_curr_node
                break
            else:
                del curr_node
                if is_direction_left:
                    prev_node.left = None
                else:
                    prev_node.right = None
                break 
    return tree_root

class Solution:
    def successor(self, root):
        """
        One step right and then always left
        """
        root = root.right
        while root.left:
            root = root.left
        return root.val
    
    def predecessor(self, root):
        """
        One step left and then always right
        """
        root = root.left
        while root.right:
            root = root.right
        return root.val
        
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if not root:
            return None
        
        # delete from the right subtree
        if key > root.val:
            root.right = self.deleteNode(root.right, key)
        # delete from the left subtree
        elif key < root.val:
            root.left = self.deleteNode(root.left, key)
        # delete the current node
        else:
            # the node is a leaf
            if not (root.left or root.right):
                root = None
            # the node is not a leaf and has a right child
            elif root.right:
                root.val = self.successor(root)
                root.right = self.deleteNode(root.right, root.val)
            # the node is not a leaf, has no right child, and has a left child    
            else:
                root.val = self.predecessor(root)
                root.left = self.deleteNode(root.left, root.val)
                        
        return root


def get_successor_index(nums,key):
    left=0
    mid = len(nums)//2
    right=len(nums)
        
    while(right-left>1):
        if key<nums[mid]:
            right=mid
            mid=right//2
        elif key>nums[mid]:
            left=mid
            mid=mid+(right-left)//2
        else:
            return mid
    return right

def depth_first_search(tree_root):
    if not tree_root:
        return
    depth_first_search(tree_root.left)
    print(tree_root.val)
    depth_first_search(tree_root.right)

class BinaryTree():
    def __init__(self, input_list = list()):
        if not len(input_list):
            self.tree_root = TreeNode(0)
        else:
            self.tree_root = self.convert_list_to_tree(input_list)

    def convert_list_to_tree(self, input_list):
        if not len(input_list):
            return TreeNode(0)
        root_node = input_list[0]
        temp = root_node
        for num in input_list[1:]:
            if temp.left is None:
                temp.left = TreeNode(num)
            elif num > temp.left.val:
                temp_val = temp.left.val
                temp.left.val = num
                temp.right = TreeNode(temp_val)
            else:
                temp.right = TreeNode(num)
                temp = temp.left
        return root_node

    def print_tree():
        tree_end = False
        curr_node = self.tree_root
        #while not tree_end:
        return True

def heap_sort(num_list):
    #pdb.set_trace()
    num_list = heapify(num_list, len(num_list))
    print("heapify whole list")
    print(num_list)

    for index in range(len(num_list)-1,1,-1):
        print("heapify till "+str(index))
        num_list[index],num_list[0] = num_list[0],num_list[index]
        #pdb.set_trace()
        num_list = heapify(num_list, index)
        print(num_list)
    return num_list

def heapify(num_list,length):
    for index in range(length//2,-1,-1):
        num_list = build_heap(num_list,index,length)
    return num_list

def build_heap(num_list,index,length):
    left = (2*index)
    right = left+1
    if(left+1 > length):
        return num_list
    largest = index
    if num_list[left] > num_list[largest]:
        largest = left
    if(right+1 < length and num_list[right] > num_list[largest]):
        largest = right
    if(largest != index):
        num_list[largest],num_list[index] = num_list[index],num_list[largest]
        num_list=build_heap(num_list,largest,length)
    return num_list

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right


def left(i):
    print("left:",str(i))
    return 2*i

def right(i):
    return 2*i+1

def new_max_heapify_tree(root):
    if not root:
        return None
    if (root.left.val > root.val or root.right.val > root.val):
        if (root.left.val > root.right.val):
            root.val,root.left.val = root.left.val,root.val
            root.left = new_max_heapify(root.left)
        else:
            root.val,root.right.val = root.right.val,root.val
            root.right = new_max_heapify(root.right)
    return root

def new_max_heapify_list(num_list,index):
    try:
        left_num = num_list[left(index)-1]
        right_num = num_list[right(index)-1] 
        root_num = num_list[index-1]
    except IndexError:
        return num_list
    if (left_num > root_num or right_num > root_num):
        if (left_num > right_num):
            num_list[left(index)-1],num_list[index-1] = num_list[index-1],num_list[left(index)-1]
            num_list = new_max_heapify_list(num_list,left(index))
        else:
            num_list[right(index)-1],num_list[index-1] = num_list[index-1],num_list[right(index)-1]
            num_list = new_max_heapify_list(num_list,right(index))
    return num_list

def new_build_heap(num_list):
    for index in range(len(num_list)//2,0,-1):
        num_list = new_max_heapify_list(num_list,index)
    return num_list

def new_heap_sort(num_list):
    pdb.set_trace()
    for index in range(len(num_list),0,-1):
        num_list_part = new_build_heap(num_list[:index])
        num_list = num_list_part+num_list[index:]
        num_list[0],num_list[index-1] = num_list[index-1],num_list[0]
    print(num_list)



class Solution:
    def insertIntoBST(self, root, val):
        if not root: return TreeNode(val)
        if root.val > val:
            root.left = self.insertIntoBST(root.left, val)
        elif root.val < val:
            root.right = self.insertIntoBST(root.right, val)
        return root 

def insertionSort(nums):
    if not nums:
        return nums

    for index1 in range(1,len(nums)):
        index2=index1-1
        while(nums[index1]<nums[index2]):
            nums[index1],nums[index2]=nums[index2],nums[index1]
            if index2==0 or index1==0:
                break
            index2 -= 1
            index1 -= 1

    print(nums)

import pdb
class QuickSort:
    def sort(self,nums,start,end):
      if start >= end:
          return
      pivot = self.partition(nums,start,end)
      nums1 = self.sort(nums,0, pivot-1)
      nums2 = self.sort(nums,pivot+1, len(nums)-1)
      return nums1 + nums2

    def partition(self,nums,start,end):
      pivot = start
      l_ptr = start
      r_ptr = end
      while True:
          while l_ptr < r_ptr and nums[l_ptr] <= nums[pivot]:
              l_ptr += 1
          while l_ptr < r_ptr and nums[r_ptr] > nums[pivot]:
              r_ptr -= 1
          if l_ptr < r_ptr:
              nums[l_ptr], nums[r_ptr] = nums[r_ptr], nums[l_ptr]
          else:
              break
      #pdb.set_trace()
      nums[r_ptr], nums[pivot] = nums[pivot], nums[r_ptr]
      return r_ptr	
	  

def mergeSort(nums):
    if not nums:
        return []
    if len(nums)==1:
        return nums

    mid = len(nums)//2
    left = mergeSort(nums[:mid])
    right = mergeSort(nums[mid:])
    #pdb.set_trace()
    if not left and not right:
        return nums
    elif not left:
        return right
    elif not right:
        return left
    ans = []
    l_index = len(left)-1
    r_index = len(right)-1
    while(l_index>=0 and r_index>=0):
        if left[l_index]<right[r_index]:
            ans.append(left[l_index])
            l_index -= 1
        elif left[l_index]==right[r_index]:
            ans.append(left[l_index])
            ans.append(right[r_index])
            l_index -= 1
            r_index -= 1
        else:
            ans.append(right[r_index])
            r_index -= 1

    while(l_index>=0):
        ans.append(left[l_index])
        l_index -= 1

    while(r_index>=0):
        ans.append(right[r_index])
        r_index -= 1

    return ans[::-1]

class MaxHeap:
    def __init__(self):
        self.heap_list = [None]
        self.heap_size = 0
    
    def insert(self,val):
        self.heap_size += 1
        self.heap_list.insert(self.heap_size,val)
        self.max_heapify_up(self.heap_size)
    
    def max_heapify_up(self,index):
        parent_id = self.get_parent_id(index)
        if parent_id :
            if self.heap_list[parent_id] < self.heap_list[index]:
                self.heap_list[parent_id], self.heap_list[index] =\
                self.heap_list[index], self.heap_list[parent_id]
                self.max_heapify_up(parent_id)
    
    def max_heapify_down(self,index):
        left_child_id = self.get_left_child_id(index)
        right_child_id = self.get_right_child_id(index)
        bigger_child_id = None
        
        if left_child_id and right_child_id:
            if self.heap_list[left_child_id] > self.heap_list[right_child_id]:
                bigger_child_id = left_child_id
            else:
                bigger_child_id = right_child_id
        elif right_child_id:
            bigger_child_id = right_child_id
        elif left_child_id:
            bigger_child_id = left_child_id
            
        if bigger_child_id and \
        self.heap_list[bigger_child_id] > self.heap_list[index]:
            self.heap_list[bigger_child_id], self.heap_list[index] =\
            self.heap_list[index], self.heap_list[bigger_child_id]
            self.max_heapify_down(bigger_child_id)    
    
    def get_parent_id(self,index):
        if index == 1:
            return None
        return index // 2
    
    def get_left_child_id(self,index):
        child_id = 2 * index
        if child_id > 1 and child_id <= self.heap_size:
            return child_id
        return None

    def get_right_child_id(self,index):
        child_id = (2 * index) + 1
        if child_id > 1 and child_id <= self.heap_size:
            return child_id
        return None

    def get_max(self):
        if self.heap_size == 0:
            return None
        max_val = self.heap_list[1]
        self.heap_list[1] = self.heap_list[self.heap_size]
        self.heap_size -= 1
        self.max_heapify_down(1)
        return max_val
        
    def print_heap(self):
        print(self.heap_list[1:])




if __name__ == "__main__":
    list1 = [5,7,1,3,6,8,9,10,2,11,15,20,14,4,12]
    #list2 = heap_sort(list1)
    #print(list2)
